---
title: GitLab CI / CDの時間を短縮する7つの方法
author: ウェス・コシック
authorURL: http://twitter.com/ericnakagawa
---

他の継続的インテグレーションおよびデプロイメントプラットフォームと同様に、速度は開発者の効率にとって非常に重要です。 最近、私たちはCIの仕事を引き受け、可能な限り速くなるようにそれらをリファクタリングしました。 これを行う方法は次のとおりです。

1. 独自のGitLabランナーをホストする

GitLab.com（GitLabがホストするSaaSオファリング）は、リポジトリーが使用する共有ランナーを提供します。 これは、すぐに地面を降りるのには素晴らしいことですが、速度を向上させるための最大の利点は、自分のランナーをホストすることによってもたらされたものです。 私たちのボトルネックは、実際にはCPUやRAMではありませんでした。それはネットワークでした。 プライベートクラウドサーバーでは、ネットワークは劇的に高速です。 私たちは、DigitalOceanとGoogle Cloud Platformの両方で速度が約2倍になることに一貫して気付きました。

ネットワーク速度は、構築と展開にとって特に重要です。 多くの場合、ビルドにはライブラリ、依存関係、Dockerイメージなどをダウンロードする必要があり、デプロイには別の場所にアセットをアップロードする必要があります。 GitLabの共有ランナーでネットワークが混雑すると、これらのステージは糖蜜のように感じる可能性があります。

素晴らしいニュースは、あなた自身のランナーを設定することは実際には非常に簡単です！ DigitalOcean、AWS、またはGCPのサーバーをすぐにスピンアップし、わずか数個のコマンドを使用してLinuxにGitLabのランナーをインストールできます。 ただ彼らの指示に従ってください。

2. インストール前の依存関係

これは大きな問題です。 CIジョブを実行するたびに依存関係をインストールする場合、時間を無駄にしています。 代わりに、必要なすべての依存関係がすでにインストールされているCIジョブにはDockerイメージを使用する必要があります。

必要なすべての依存関係があるイメージが見つからない場合は、事前にビルドして、GitLabのランナーがアクセスできるコンテナーレジストリに保存する必要があります（GitLabの組み込みコンテナーレジストリを使用したいと思います）。

3. CIイメージに小さなLinuxディストリビューションを使用する

可能な限り、CIジョブを実行するイメージには小さなLinuxディストリビューションを使用してください。 Alpine Linuxはおそらく最も人気のあるオプションですが、他にもあります。

どうして？ いくつかのテストを実行したり、いくつかのビルドコマンドを実行したりするために、Ubuntuのような肥大化したディストリビューションは必要ないでしょう。 したがって、30〜40倍のサイズのイメージをダウンロードする時間を無駄にしないでください。

4. overlay2ストレージドライバーを使用する

CIを高速化する最も簡単な方法は、デフォルトのvfsドライバーの代わりにoverlay2 Dockerストレージドライバーを使用することです（詳細）。 これを行うには、.gitlab-ci.ymlファイルの先頭に次の行を追加します。

変数： DOCKER_DRIVER：overlay2 後者よりも数秒余分に削られるので、overlayだけでなくoverlay2を使用してください。

または、独自のランナーをホストしていて、config.tomlファイルにアクセスできる場合は、[[runners]]セクションに次の行を追加して、すべてのプロジェクトでこのドライバーを自動的に有効にすることができます（詳細）。

環境= ["DOCKER_DRIVER = overlay2"]
5. 構築時にキャッシュされたDockerイメージを使用する

Dockerはスマートです—ビルドキャッシュを使用して変更されたレイヤーのみをビルドするため、イメージのビルド時間が大幅に短縮されます。 ただし、Dockerが以前のビルドを見つけられない場合（CIジョブを実行するたびに白紙の状態を使用している場合に発生します）、常に最初からイメージをビルドすることになります。

これを修正するには、-cache-fromオプション（Docker v1.13で追加）を使用して以前にビルドされたイメージがどこにあるかをDockerに通知します。 Dockerビルドオプションの詳細については、こちらをご覧ください。

6. Dockerfileを慎重に整理する

Dockerのビルドキャッシュについて言えば、その動作を理解する必要があります。 一言で言えば、各命令はレイヤーであり、各レイヤーは、変更された場合、または変更前のレイヤーが変更された場合にのみ再構築されます。 「変更」を構成するものは、それがどの種類の指示であるかによって異なりますが、その詳細については、こちらをご覧ください。

しかし重要なのは、実際に変更されていない命令を不必要に実行したくないということです。 たとえば、次のような指示でNGINXをインストールするコンテナがあるとします。

実行apt-get -y update && \ apt-get -y install nginx ソースファイルをコピーする命令をその命令の前に配置したくない場合があります（以下に示すようなもの）。

COPY source / / usr / share / nginx / html なぜですか？ ソースファイルを変更するたびにDockerをNGINXを再インストールする必要はほとんどないからです。 それはあなたのビルドを遅くするだけです。

7. GitLabの強力なCI / CD構成設定を活用する

適切に使用すると、パイプラインを大幅に高速化できる3つの便利な構成機能があります。

動的依存関係をキャッシュする

ジョブ中に特定の依存関係を動的にインストールする必要があり、何らかの理由で依存関係をCIイメージに事前ビルドできない場合は、ジョブ実行間でGitLabのキャッシュを使用することを検討してください。 ビルド間でnode_modulesディレクトリをキャッシュする方法を示す次の例を見てください。

example-job： スクリプト：
    - ヤーンインストール--frozen-lockfile --check-files キャッシュ： パス：
      - node_modules / GitLabのキャッシュの構成の詳細。

関連ファイルが変更されたときにのみジョブを実行する

これは、複数の独立したアプリまたはマイクロサービスがある可能性のあるモノリポジトリで特に役立ちます。 たとえば、1つのフロントエンドアプリのみを変更し、他のフロントエンドアプリを変更していない場合、変更されていないアプリのテストを再実行するのはなぜですか？

時間を節約するために、only：changesキーとマージリクエストのパイプラインを組み合わせて、条件付きで実行されるジョブについて考えます。 ジョブの実行を必要とするために変更する必要があるディレクトリ/ファイルをリストするだけです。 共有依存関係を含め、ジョブに影響を与える可能性のあるものをすべてリストしてください。 以下の例をご覧ください。

test-example1： スクリプト：
    - 糸--cwd apps / example1 /テスト のみ： 変更：
      - apps / example1 / ** / *
      - shared-dependencies / ** / * test-example2： スクリプト：
    -     糸--cwdアプリ/ example2 /テスト
  のみ： 変更：
      - apps / example2 / ** / *
      - shared-dependencies / ** / * この機能の使用に関する詳細。

将来の段階から早い段階でジョブを実行する

ステージは同様のジョブを整理するための優れた方法であり、ほとんどの場合、1つのステージのジョブは、前のステージのすべてのジョブが成功するまで実行されません。 しかし、考えてみれば、パイプラインには少なくともいくつかのジョブがあり、失敗してもプロジェクトに悪影響を与えることなく安全に早期に実行できます。

たとえば、Chromaticを頻繁に使用してUI回帰テストを実行します。 これらのジョブはパイプラインの最後に発生するため、失敗した場合（つまり、視覚的な変更が検出された場合）は、パイプラインがレビュー環境に変更をデプロイすることをブロックしません。 しかし、それこそが、これらのパイプラインで実行が遅くなる唯一の理由です。

これらのケースでは、ニーズキーを使用して、将来のステージでジョブを実行する前に渡す必要がある、初期のステージからの限定されたジョブのセットを指定することを検討してください。 特にパイプラインの終わりに向かって遅いジョブで効果的に使用すると、かなりの時間を節約できます。

ニーズキーの使用について詳しくは、こちらをご覧ください。 これがGitLabでCI / CDの時間を短縮するのに役立つ場合は、拍手で感謝を示してください！ そして、あなたが他の役に立つヒントを知っているなら、以下のコメントでそれらを共有してください。
