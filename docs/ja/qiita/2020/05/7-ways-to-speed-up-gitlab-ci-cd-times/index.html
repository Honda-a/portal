<!DOCTYPE html><html lang="ja"><head><meta charSet="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><title>GitLab CI / CDの時間を短縮する7つの方法 · baby-degu</title><meta name="viewport" content="width=device-width"/><meta name="generator" content="Docusaurus"/><meta name="description" content="![](https://cdn-images-1.medium.com/max/4000/1*bq3t_FxBR4sogEjaAQb-3w.jpeg)"/><meta name="docsearch:language" content="ja"/><meta property="og:title" content="GitLab CI / CDの時間を短縮する7つの方法 · baby-degu"/><meta property="og:type" content="website"/><meta property="og:url" content="https://baby-degu.github.io/"/><meta property="og:description" content="![](https://cdn-images-1.medium.com/max/4000/1*bq3t_FxBR4sogEjaAQb-3w.jpeg)"/><meta property="og:image" content="https://baby-degu.github.io/img/baby-degu.jpg"/><meta name="twitter:card" content="summary"/><meta name="twitter:image" content="https://baby-degu.github.io/img/baby-degu.jpg"/><link rel="shortcut icon" href="/img/favicon.ico"/><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css"/><link rel="alternate" type="application/atom+xml" href="https://baby-degu.github.io/blog/atom.xml" title="baby-degu Blog ATOM Feed"/><link rel="alternate" type="application/rss+xml" href="https://baby-degu.github.io/blog/feed.xml" title="baby-degu Blog RSS Feed"/><script type="text/javascript" src="https://buttons.github.io/buttons.js"></script><script src="/js/scrollSpy.js"></script><link rel="stylesheet" href="/css/main.css"/><script src="/js/codetabs.js"></script></head><body class="sideNavVisible separateOnPageNav"><div class="fixedHeaderContainer"><div class="headerWrapper wrapper"><header><a href="/ja"><h2 class="headerTitle">baby-degu</h2></a><div class="navigationWrapper navigationSlider"><nav class="slidingNav"><ul class="nav-site nav-site-internal"><li class=""><a href="/docs/ja/" target="_self">Projects</a></li><li class=""><a href="https://github.com/baby-degu/portal" target="_blank">Github</a></li><li class=""><a href="/blog/" target="_self">ブログ</a></li><span><li><a id="languages-menu" href="#"><img class="languages-icon" src="/img/language.svg" alt="Languages icon"/>日本語</a><div id="languages-dropdown" class="hide"><ul id="languages-dropdown-items"><li><a href="/docs/en/qiita/2020/05/7-ways-to-speed-up-gitlab-ci-cd-times">English</a></li></ul></div></li><script>
        const languagesMenuItem = document.getElementById("languages-menu");
        const languagesDropDown = document.getElementById("languages-dropdown");
        languagesMenuItem.addEventListener("click", function(event) {
          event.preventDefault();

          if (languagesDropDown.className == "hide") {
            languagesDropDown.className = "visible";
          } else {
            languagesDropDown.className = "hide";
          }
        });
      </script></span></ul></nav></div></header></div></div><div class="navPusher"><div class="docMainWrapper wrapper"><div class="container mainContainer docsContainer"><div class="wrapper"><div class="post"><header class="postHeader"><h1 id="__docusaurus" class="postHeaderTitle">GitLab CI / CDの時間を短縮する7つの方法</h1></header><article><div><span><p><img src="https://cdn-images-1.medium.com/max/4000/1*bq3t_FxBR4sogEjaAQb-3w.jpeg" alt=""></p>
<p>他の継続的インテグレーションおよびデプロイメントプラットフォームと同様に、速度は開発者の効率にとって非常に重要です。 最近、私たちはCIの仕事を引き受け、可能な限り速くなるようにそれらをリファクタリングしました。 これを行う方法は次のとおりです。</p>
<h2><a class="anchor" aria-hidden="true" id="1。-独自のgitlabランナーをホストする"></a><a href="#1。-独自のgitlabランナーをホストする" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>1。 独自のGitLabランナーをホストする</h2>
<p>GitLab.com <em>（GitLabがホストするSaaSオファリング）</em> は、リポジトリーが使用する共有ランナーを提供します。 これは、すぐに地面を降りるのには素晴らしいことですが、速度を向上させるための最大の利点は、自分のランナーをホストすることによってもたらされたものです。 私たちのボトルネックは、実際にはCPUやRAMではありませんでした。それはネットワークでした。 プライベートクラウドサーバーでは、ネットワークは劇的に高速です。 私たちは、DigitalOceanとGoogle Cloud Platformの両方で速度が約2倍になることに一貫して気付きました。</p>
<p>ネットワーク速度は、構築と展開にとって特に重要です。 多くの場合、ビルドにはライブラリ、依存関係、Dockerイメージなどをダウンロードする必要があり、デプロイには別の場所にアセットをアップロードする必要があります。 GitLabの共有ランナーでネットワークが混雑すると、これらのステージは糖蜜のように感じる可能性があります。</p>
<p>素晴らしいニュースは、あなた自身のランナーを設定することは実際には非常に簡単です！ あなたはからサーバーをスピンアップすることができます <a href="https://www.digitalocean.com/">DigitalOcean</a>、 <a href="https://aws.amazon.com/">AWS</a>、または <a href="https://cloud.google.com/">GCP</a> 次・ツー・ノー・タイムで、ほんの数コマンドでLinux上GitLabのランナーをインストールします。 ただ、続く <a href="https://docs.gitlab.com/runner/install/linux-repository.html">その指示</a>。</p>
<h2><a class="anchor" aria-hidden="true" id="2。-インストール前の依存関係"></a><a href="#2。-インストール前の依存関係" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>2。 インストール前の依存関係</h2>
<p>これは大きな問題です。 CIジョブを実行するたびに依存関係をインストールする場合、時間を無駄にしています。 代わりに、必要なすべての依存関係がすでにインストールされているCIジョブにはDockerイメージを使用する必要があります。</p>
<p>必要なすべての依存関係があるイメージが見つからない場合は、事前にビルドして、GitLabのランナーがアクセスできるコンテナーレジストリに保存する必要があります（GitLabの <a href="https://docs.gitlab.com/ee/user/project/container_registry.html">組み込みコンテナーレジストリ</a>を使用したい）。</p>
<h2><a class="anchor" aria-hidden="true" id="3。-ciイメージに小さなlinuxディストリビューションを使用する"></a><a href="#3。-ciイメージに小さなlinuxディストリビューションを使用する" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>3。 CIイメージに小さなLinuxディストリビューションを使用する</h2>
<p>可能な限り、CIジョブを実行するイメージには小さなLinuxディストリビューションを使用してください。 <a href="https://alpinelinux.org/">Alpine Linux</a> はおそらく最も人気のあるオプションですが、他にもあります。</p>
<p>どうして？ いくつかのテストを実行したり、いくつかのビルドコマンドを実行したりするために、Ubuntuのような肥大化したディストリビューションは必要ないでしょう。 したがって、30〜40倍のサイズのイメージをダウンロードする時間を無駄にしないでください。</p>
<h2><a class="anchor" aria-hidden="true" id="4。-overlay2ストレージドライバーを使用する"></a><a href="#4。-overlay2ストレージドライバーを使用する" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>4。 overlay2ストレージドライバーを使用する</h2>
<p>CIを高速化する最も簡単な方法は、デフォルトのvfsドライバーの代わりにoverlay2 Dockerストレージドライバーを使用することです（<a href="https://docs.gitlab.com/ce/ci/docker/using_docker_build.html#using-the-overlayfs-driver">詳細</a>）。 これを行うには、.gitlab-ci.ymlファイルの先頭に次の行を追加します。</p>
<pre><code class="hljs">変数：
  DOCKER_DRIVER：overlay2
</code></pre>
<p>後者ではなく、数秒余分に削られるので、overlayだけでなくoverlay2を使用してください。</p>
<p>または、独自のランナーをホストしていて、config.tomlファイルにアクセスできる場合は、[[runners]]セクションに次の行を追加することにより、すべてのプロジェクトでこのドライバーを自動的に有効にすることができます（<a href="https://docs.gitlab.com/ce/ci/docker/using_docker_build.html#use-driver-for-every-project">詳細</a>）：</p>
<pre><code class="hljs">環境= [&quot;DOCKER_DRIVER = overlay2&quot;]
</code></pre>
<h2><a class="anchor" aria-hidden="true" id="5。-構築時にキャッシュされたdockerイメージを使用する"></a><a href="#5。-構築時にキャッシュされたdockerイメージを使用する" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>5。 構築時にキャッシュされたDockerイメージを使用する</h2>
<p>Dockerはスマートです—ビルドキャッシュを使用して変更されたレイヤーのみをビルドするため、イメージのビルド時間が大幅に短縮されます。 ただし、Dockerが以前のビルドを見つけられない場合（CIジョブを実行するたびに白紙の状態を使用している場合に発生します）、常に最初からイメージをビルドすることになります。</p>
<p>これを修正するには、-cache-fromオプション <em>（Docker v1.13で追加）</em>して、以前にビルドされたイメージがどこにあるかをDockerに通知します。 docker build options <a href="https://docs.docker.com/edge/engine/reference/commandline/build/#options">詳細については、こちら</a>ご覧ください。</p>
<h2><a class="anchor" aria-hidden="true" id="6。-dockerfileを慎重に整理する"></a><a href="#6。-dockerfileを慎重に整理する" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>6。 Dockerfileを慎重に整理する</h2>
<p>Dockerのビルドキャッシュについて言えば、その動作を理解する必要があります。 一言で言えば、各命令はレイヤーであり、各レイヤーは、変更された場合、または変更前のレイヤーが変更された場合にのみ再構築されます。 命令の種類に基づいて、「変更」が異なっを構成するものではありますが、次のことが可能 <a href="https://docs.docker.com/engine/userguide/eng-image/dockerfile_best-practices/#build-cache">、ここでそれについての詳細を学ぶ</a>。</p>
<p>重要なものは、しかし、あなたが持っていない不必要に実行指示をしたくないということである <em>本当に</em> に変更。 たとえば、次のような指示でNGINXをインストールするコンテナがあるとします。</p>
<pre><code class="hljs">実行apt-get -y update &amp;&amp; \
    apt-get -y install nginx
</code></pre>
<p>おそらく、そのファイルがコピー元を超える命令配置する必要はありません <em>の前に</em> 、その命令（以下のような）を。</p>
<pre><code class="hljs">コピー元/ / usr / share / nginx / html
</code></pre>
<p>どうして？ ソースファイルを変更するたびにDockerをNGINXを再インストールする必要はほとんどないからです。 それはあなたのビルドを遅くするだけです。</p>
<h2><a class="anchor" aria-hidden="true" id="7。-gitlabの強力なci--cd構成設定を活用する"></a><a href="#7。-gitlabの強力なci--cd構成設定を活用する" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>7。 GitLabの強力なCI / CD構成設定を活用する</h2>
<p>適切に使用すると、パイプラインを大幅に高速化できる3つの便利な構成機能があります。</p>
<h3><a class="anchor" aria-hidden="true" id="動的依存関係をキャッシュする"></a><a href="#動的依存関係をキャッシュする" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>動的依存関係をキャッシュする</h3>
<p>ジョブ中に特定の依存関係を動的にインストールする必要があり、何らかの理由で依存関係をCIイメージに事前ビルドできない場合は、ジョブ実行間でGitLabのキャッシュを使用することを検討してください。 ビルド間でnode_modulesディレクトリをキャッシュする方法を示す次の例を見てください。</p>
<pre><code class="hljs">example-job：
  スクリプト：

    糸のインストール--frozen-lockfile --check-files
  キャッシュ：
    パス：

      -node_modules /
</code></pre>
<p>詳細はこちら <a href="https://docs.gitlab.com/ee/ci/yaml/#cache">GitLabのキャッシュの設定</a>。</p>
<h3><a class="anchor" aria-hidden="true" id="関連ファイルが変更されたときにのみジョブを実行する"></a><a href="#関連ファイルが変更されたときにのみジョブを実行する" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>関連ファイルが変更されたときにのみジョブを実行する</h3>
<p>これは、複数の独立したアプリまたはマイクロサービスがある可能性のあるモノリポジトリで特に役立ちます。 たとえば、1つのフロントエンドアプリのみを変更し、他のフロントエンドアプリを変更していない場合、変更されていないアプリのテストを再実行するのはなぜですか？</p>
<p>時間を節約するために、条件付きで実行されるジョブについて、only：changesキーとマージリクエストの <a href="https://docs.gitlab.com/ee/ci/merge_request_pipelines/index.html">パイプラインをペアにすることを検討してください</a>。 ジョブの実行を必要とするために変更する必要があるディレクトリ/ファイルをリストするだけです。 共有依存関係を含め、ジョブに影響を与える可能性のあるものをすべてリストしてください。 以下の例をご覧ください。</p>
<pre><code class="hljs">test-example1：
  スクリプト：

    糸--cwd apps / example1 / test
  のみ：
    変更：

      -apps / example1 / ** / *
      -shared-dependencies / ** / *

test-example2：
  スクリプト：

    -yarn --cwd apps / example2 / test
  のみ：
    変更：

      -apps / example2 / ** / *
      -shared-dependencies / ** / *
</code></pre>
<p>この機能を使用した <a href="https://docs.gitlab.com/ee/ci/yaml/#onlychangesexceptchanges">詳細</a></p>
<h3><a class="anchor" aria-hidden="true" id="将来の段階から早い段階でジョブを実行する"></a><a href="#将来の段階から早い段階でジョブを実行する" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>将来の段階から早い段階でジョブを実行する</h3>
<p>ステージは同様のジョブを整理するための優れた方法であり、ほとんどの場合、1つのステージのジョブは、前のステージのすべてのジョブが成功するまで実行されません。 しかし、考えてみれば、パイプラインには少なくともいくつかのジョブがあり、失敗してもプロジェクトに悪影響を与えることなく安全に早期に実行できます。</p>
<p>たとえば、UI回帰テストを実行するために <a href="https://www.chromaticqa.com/">Chromatic</a> を頻繁に使用します。 これらのジョブはパイプラインの最後に発生するため、失敗した場合（つまり、視覚的な変更が検出された場合）は、パイプラインがレビュー環境に変更をデプロイすることをブロックしません。 しかし、それこそが、これらのパイプラインで実行が遅くなる唯一の理由です。</p>
<p>これらのケースでは、ニーズキーを使用して、将来のステージでジョブを実行する前に渡す必要がある、初期のステージからの限定されたジョブのセットを指定することを検討してください。 特にパイプラインの終わりに向かって遅いジョブで効果的に使用すると、かなりの時間を節約できます。</p>
<p>ニーズキー</a>を使用した 詳細。</p></p>
</span></div></article></div><div class="docs-prevnext"></div></div></div><nav class="onPageNav"><ul class="toc-headings"><li><a href="#1。-独自のgitlabランナーをホストする">1。 独自のGitLabランナーをホストする</a></li><li><a href="#2。-インストール前の依存関係">2。 インストール前の依存関係</a></li><li><a href="#3。-ciイメージに小さなlinuxディストリビューションを使用する">3。 CIイメージに小さなLinuxディストリビューションを使用する</a></li><li><a href="#4。-overlay2ストレージドライバーを使用する">4。 overlay2ストレージドライバーを使用する</a></li><li><a href="#5。-構築時にキャッシュされたdockerイメージを使用する">5。 構築時にキャッシュされたDockerイメージを使用する</a></li><li><a href="#6。-dockerfileを慎重に整理する">6。 Dockerfileを慎重に整理する</a></li><li><a href="#7。-gitlabの強力なci--cd構成設定を活用する">7。 GitLabの強力なCI / CD構成設定を活用する</a><ul class="toc-headings"><li><a href="#動的依存関係をキャッシュする">動的依存関係をキャッシュする</a></li><li><a href="#関連ファイルが変更されたときにのみジョブを実行する">関連ファイルが変更されたときにのみジョブを実行する</a></li><li><a href="#将来の段階から早い段階でジョブを実行する">将来の段階から早い段階でジョブを実行する</a></li></ul></li></ul></nav></div><footer class="nav-footer" id="footer"><section class="sitemap"><a href="/" class="nav-home"></a><div><h5>Categories</h5><a href="/docs/ja/qiita/index.html">Qiita</a><a href="/docs/ja/udemy/index.html">Udemy</a><a href="/docs/ja/dao/index.html">DAO</a></div><div><h5>Community</h5><a href="https://discord.gg/9e82Y3r" target="_blank" rel="noreferrer noopener">Project Chat</a><a href="https://twitter.com/babydegu" target="_blank" rel="noreferrer noopener">Twitter</a></div><div><h5>More</h5><a href="/blog">Blog</a><a href="https://github.com/baby-degu">GitHub</a><a class="github-button" href="https://github.com/baby-degu/portal" data-icon="octicon-star" data-count-href="/facebook/docusaurus/stargazers" data-show-count="true" data-count-aria-label="# stargazers on GitHub" aria-label="Star this project on GitHub">Star</a><div class="social"><a href="https://twitter.com/babydegu" class="twitter-follow-button">Follow @babydegu</a></div></div></section><section class="copyright"><a href="https://creativecommons.org/licenses/by-sa/4.0/" target="_blank" rel="noreferrer noopener">Content is licensed under CC BY-SA 4.0</a></section></footer></div><script>window.twttr=(function(d,s, id){var js,fjs=d.getElementsByTagName(s)[0],t=window.twttr||{};if(d.getElementById(id))return t;js=d.createElement(s);js.id=id;js.src='https://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js, fjs);t._e = [];t.ready = function(f) {t._e.push(f);};return t;}(document, 'script', 'twitter-wjs'));</script></body></html>